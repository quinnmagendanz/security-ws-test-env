## Place your answers here

Memory Corruption Bugs

[http.c:276]
[Implemented] The pn variable can be overflowed in the http_serve function by an input path which is greater than 1024 bytes. An additional 4 bytes after these 1024 bytes will override the function call "handler" to point to a different function. Once this is done, a call to handler will take control flow of the program. This attack is not preventable by a stack canary because we are overriding a function pointer which is pushed to the stack after the function would push the stack canary, and would thus not override it.


[zookd.c:105]
The reqpath variable can be overwritten in url_decode by a url which is larger than 2048 chars. reqpath gets passed into http_read_line then url_decode, and if the path is longer than 2048, it will begin to override other data such as env_len and the function pushes (including the return address). Changing the return address to code injected into the buffer can allow for grades.txt deletion. This can be prevented by a stack canary because reqpath is on the stack and we need to override the function pushes which would include the stack canary. Since this attack uses the return address to redirect control flow, we can use unlink on a non-executable stack in the same way as we did in the first exploit, writing the filepath and its string pointer during the overflow to use as argument to unlink.


[http.c:120]
[Implemented] The value variable can be overwritten in url_decode by a url header which is larger than 512 chars. You would structure the imput by filling the 512 buffer with code/NOPs and then overflowing the 24 extra bytes bytes between the buffer and the return address and then the return address. This can be done using a large header. This can be prevented by a stack canary because value is on the stack and a stack canary on funtion push would be overridden.


[http.c:353]
The name buffer can be overriden using a path longer than 1024 during the dir_join function. This would overwrite the buffer, and additional input would begin to overflow the pushed function parameters like the return address. Changing the return address to code injected in the buffer can allow for deletion of grades.txt. The stack canary would also be overriden, making it a valid technique for detection. Since this attack uses the return address to redirect control flow, we can use unlink on a non-executable stack in the same way as we did in the first exploit, writing the filepath and its string pointer during the overflow to use as argument to unlink.


[zookd.c:103]
This memory corruption and buffer overflow example exploits a format string attack in the sprintf function. If an input string into sprintf is too large, it is not bounds checked and will overwrite the envp buffer and cause memory corruption and ultimately override the return address of process client. Changing the return address would allow for redirection of injected code and deletion of the grades.txt file. This can be prevented by a stack canary because the buffer is within the function and needs to override pushed function variables to get to the return address. Since this attack uses the return address to redirect control flow, we can use unlink on a non-executable stack in the same way as we did in the first exploit, writing the filepath and its string pointer during the overflow to use as argument to unlink.


Additional Bugs

[http.c:94]
This bug leaves the program open to format string attacks of various purposes.  If an input string into sprintf is too long, bounds are not checked and it can overwrite a buffer. 

[http.c:344]
strcpy and strcat are vulnerable functions which are used multiple times throughout the code. strycpy and strcat do not check bounds while performing their respective string operations and can result in buffer overflows as seen in the [http.c:276] implemented buffer overflow.

[http.c:19]
If the attacker can override a static buffer elsewhere in the program, they could change the filepath of the access check so that when touch checks if it has access to "tmp/grading", it will instead check a different file and give permission. The attacker could similarly change the symbolic link "tmp/grading" to point to a different file. 

[http.c:166]
setenv does not check bounds or validate input data before saving to environment. If env in overflown, this could cause issues. Not sure if the sum of all variables added to the env is enough to overflow the 8192 byte buffer.  
